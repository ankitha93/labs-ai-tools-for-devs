/*
Docker Desktop secrets API

This Docker Desktop API manages user secrets to be injected in containers.

API version: 0.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package secretsapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type SecretsApi interface {

	/*
		DeleteJfsPolicy deletes a policy

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param policy
		@return ApiDeleteJfsPolicyRequest
	*/
	DeleteJfsPolicy(ctx context.Context, policy string) ApiDeleteJfsPolicyRequest

	// DeleteJfsPolicyExecute executes the request
	DeleteJfsPolicyExecute(r ApiDeleteJfsPolicyRequest) (*http.Response, error)

	/*
		DeleteJfsSecret deletes a secret

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param secret
		@return ApiDeleteJfsSecretRequest
	*/
	DeleteJfsSecret(ctx context.Context, secret string) ApiDeleteJfsSecretRequest

	// DeleteJfsSecretExecute executes the request
	DeleteJfsSecretExecute(r ApiDeleteJfsSecretRequest) (*http.Response, error)

	/*
		GetJfsPolicy retrieves a policy

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param policy
		@return ApiGetJfsPolicyRequest
	*/
	GetJfsPolicy(ctx context.Context, policy string) ApiGetJfsPolicyRequest

	// GetJfsPolicyExecute executes the request
	//  @return Policy
	GetJfsPolicyExecute(r ApiGetJfsPolicyRequest) (*Policy, *http.Response, error)

	/*
		GetJfsSecret checks if a secret exists

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param secret
		@return ApiGetJfsSecretRequest
	*/
	GetJfsSecret(ctx context.Context, secret string) ApiGetJfsSecretRequest

	// GetJfsSecretExecute executes the request
	//  @return Secret
	GetJfsSecretExecute(r ApiGetJfsSecretRequest) (*Secret, *http.Response, error)

	/*
		ListJfsPolicies lists all policies

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListJfsPoliciesRequest
	*/
	ListJfsPolicies(ctx context.Context) ApiListJfsPoliciesRequest

	// ListJfsPoliciesExecute executes the request
	//  @return []Policy
	ListJfsPoliciesExecute(r ApiListJfsPoliciesRequest) ([]Policy, *http.Response, error)

	/*
		ListJfsSecrets lists all secrets

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListJfsSecretsRequest
	*/
	ListJfsSecrets(ctx context.Context) ApiListJfsSecretsRequest

	// ListJfsSecretsExecute executes the request
	//  @return []StoredSecret
	ListJfsSecretsExecute(r ApiListJfsSecretsRequest) ([]StoredSecret, *http.Response, error)

	/*
		SetJfsPolicy sets the policy

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSetJfsPolicyRequest
	*/
	SetJfsPolicy(ctx context.Context) ApiSetJfsPolicyRequest

	// SetJfsPolicyExecute executes the request
	SetJfsPolicyExecute(r ApiSetJfsPolicyRequest) (*http.Response, error)

	/*
		SetJfsSecret sets a secret value

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSetJfsSecretRequest
	*/
	SetJfsSecret(ctx context.Context) ApiSetJfsSecretRequest

	// SetJfsSecretExecute executes the request
	SetJfsSecretExecute(r ApiSetJfsSecretRequest) (*http.Response, error)
}

// SecretsApiService SecretsApi service
type SecretsApiService service

type ApiDeleteJfsPolicyRequest struct {
	ctx        context.Context
	ApiService SecretsApi
	policy     string
}

func (r ApiDeleteJfsPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteJfsPolicyExecute(r)
}

/*
DeleteJfsPolicy deletes a policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policy
	@return ApiDeleteJfsPolicyRequest
*/
func (a *SecretsApiService) DeleteJfsPolicy(ctx context.Context, policy string) ApiDeleteJfsPolicyRequest {
	return ApiDeleteJfsPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		policy:     policy,
	}
}

// Execute executes the request
func (a *SecretsApiService) DeleteJfsPolicyExecute(r ApiDeleteJfsPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.DeleteJfsPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{policy}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy"+"}", url.PathEscape(parameterToString(r.policy, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteJfsSecretRequest struct {
	ctx        context.Context
	ApiService SecretsApi
	secret     string
}

func (r ApiDeleteJfsSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteJfsSecretExecute(r)
}

/*
DeleteJfsSecret deletes a secret

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secret
	@return ApiDeleteJfsSecretRequest
*/
func (a *SecretsApiService) DeleteJfsSecret(ctx context.Context, secret string) ApiDeleteJfsSecretRequest {
	return ApiDeleteJfsSecretRequest{
		ApiService: a,
		ctx:        ctx,
		secret:     secret,
	}
}

// Execute executes the request
func (a *SecretsApiService) DeleteJfsSecretExecute(r ApiDeleteJfsSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.DeleteJfsSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/{secret}"
	localVarPath = strings.Replace(localVarPath, "{"+"secret"+"}", url.PathEscape(parameterToString(r.secret, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetJfsPolicyRequest struct {
	ctx        context.Context
	ApiService SecretsApi
	policy     string
}

func (r ApiGetJfsPolicyRequest) Execute() (*Policy, *http.Response, error) {
	return r.ApiService.GetJfsPolicyExecute(r)
}

/*
GetJfsPolicy retrieves a policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policy
	@return ApiGetJfsPolicyRequest
*/
func (a *SecretsApiService) GetJfsPolicy(ctx context.Context, policy string) ApiGetJfsPolicyRequest {
	return ApiGetJfsPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		policy:     policy,
	}
}

// Execute executes the request
//
//	@return Policy
func (a *SecretsApiService) GetJfsPolicyExecute(r ApiGetJfsPolicyRequest) (*Policy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Policy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.GetJfsPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{policy}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy"+"}", url.PathEscape(parameterToString(r.policy, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJfsSecretRequest struct {
	ctx        context.Context
	ApiService SecretsApi
	secret     string
}

func (r ApiGetJfsSecretRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.GetJfsSecretExecute(r)
}

/*
GetJfsSecret checks if a secret exists

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secret
	@return ApiGetJfsSecretRequest
*/
func (a *SecretsApiService) GetJfsSecret(ctx context.Context, secret string) ApiGetJfsSecretRequest {
	return ApiGetJfsSecretRequest{
		ApiService: a,
		ctx:        ctx,
		secret:     secret,
	}
}

// Execute executes the request
//
//	@return Secret
func (a *SecretsApiService) GetJfsSecretExecute(r ApiGetJfsSecretRequest) (*Secret, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.GetJfsSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/{secret}"
	localVarPath = strings.Replace(localVarPath, "{"+"secret"+"}", url.PathEscape(parameterToString(r.secret, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJfsPoliciesRequest struct {
	ctx        context.Context
	ApiService SecretsApi
}

func (r ApiListJfsPoliciesRequest) Execute() ([]Policy, *http.Response, error) {
	return r.ApiService.ListJfsPoliciesExecute(r)
}

/*
ListJfsPolicies lists all policies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListJfsPoliciesRequest
*/
func (a *SecretsApiService) ListJfsPolicies(ctx context.Context) ApiListJfsPoliciesRequest {
	return ApiListJfsPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Policy
func (a *SecretsApiService) ListJfsPoliciesExecute(r ApiListJfsPoliciesRequest) ([]Policy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Policy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.ListJfsPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJfsSecretsRequest struct {
	ctx        context.Context
	ApiService SecretsApi
}

func (r ApiListJfsSecretsRequest) Execute() ([]StoredSecret, *http.Response, error) {
	return r.ApiService.ListJfsSecretsExecute(r)
}

/*
ListJfsSecrets lists all secrets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListJfsSecretsRequest
*/
func (a *SecretsApiService) ListJfsSecrets(ctx context.Context) ApiListJfsSecretsRequest {
	return ApiListJfsSecretsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []StoredSecret
func (a *SecretsApiService) ListJfsSecretsExecute(r ApiListJfsSecretsRequest) ([]StoredSecret, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []StoredSecret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.ListJfsSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetJfsPolicyRequest struct {
	ctx        context.Context
	ApiService SecretsApi
	policy     *Policy
}

// the policy to be set
func (r ApiSetJfsPolicyRequest) Policy(policy Policy) ApiSetJfsPolicyRequest {
	r.policy = &policy
	return r
}

func (r ApiSetJfsPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetJfsPolicyExecute(r)
}

/*
SetJfsPolicy sets the policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetJfsPolicyRequest
*/
func (a *SecretsApiService) SetJfsPolicy(ctx context.Context) ApiSetJfsPolicyRequest {
	return ApiSetJfsPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SecretsApiService) SetJfsPolicyExecute(r ApiSetJfsPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SetJfsPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policy == nil {
		return nil, reportError("policy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetJfsSecretRequest struct {
	ctx        context.Context
	ApiService SecretsApi
	secret     *Secret
}

// the secret to be set
func (r ApiSetJfsSecretRequest) Secret(secret Secret) ApiSetJfsSecretRequest {
	r.secret = &secret
	return r
}

func (r ApiSetJfsSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetJfsSecretExecute(r)
}

/*
SetJfsSecret sets a secret value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetJfsSecretRequest
*/
func (a *SecretsApiService) SetJfsSecret(ctx context.Context) ApiSetJfsSecretRequest {
	return ApiSetJfsSecretRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SecretsApiService) SetJfsSecretExecute(r ApiSetJfsSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SetJfsSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.secret == nil {
		return nil, reportError("secret is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secret
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
